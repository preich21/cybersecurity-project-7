#!/usr/bin/env python3
"""
Exploit Demonstration: Unvalidated Update Vulnerability (CWE-345)

This script demonstrates how an attacker can exploit the unvalidated update
mechanism in insecure-application.py to inject malicious code.

DISCLAIMER: This is for educational purposes only. Do not use this against
systems you do not own or have permission to test.

Attack Scenario:
1. The insecure application downloads updates from http://example.com/fake-update.txt
2. It does NOT verify the integrity (checksum/signature) of the downloaded file
3. An attacker performing a Man-in-the-Middle (MITM) attack can intercept
   the HTTP traffic and replace the legitimate update with malicious content
4. The application blindly accepts and "applies" the malicious update

This exploit simulates the attack by:
- Setting up a fake HTTP server that serves malicious updates
- Demonstrating how the insecure application accepts any content
- Showing the difference with the secure application that validates checksums
"""

import http.server
import socketserver
import threading
import time
import sys
import os
import hashlib

# Malicious payload that would be served by attacker
MALICIOUS_UPDATE = """
# Malicious Update Payload
# In a real attack, this could contain:
# - Backdoor code
# - Data exfiltration scripts
# - Ransomware
# - Crypto miners
# - Credential stealers

import os
import sys

print("=" * 60)
print("MALICIOUS CODE EXECUTED!")
print("=" * 60)
print("This update was NOT verified!")
print("In a real attack, this could:")
print("  - Steal credentials and sensitive data")
print("  - Install backdoors for persistent access")
print("  - Encrypt files for ransomware")
print("  - Mine cryptocurrency")
print("  - Pivot to other systems on the network")
print("=" * 60)

# Simulated malicious actions (safe for demo):
print(f"Current user: {os.getenv('USER', 'unknown')}")
print(f"Current directory: {os.getcwd()}")
print(f"Python version: {sys.version}")
"""

LEGITIMATE_UPDATE = """
# Legitimate Update v2.0.0
# This is a safe, verified update

print("Update v2.0.0 applied successfully!")
print("New features:")
print("  - Enhanced security")
print("  - Bug fixes")
print("  - Performance improvements")
"""


class MaliciousUpdateServer(http.server.SimpleHTTPRequestHandler):
    """
    Simulates an attacker's server or a MITM attack that serves malicious updates.
    """
    
    def do_GET(self):
        """Handle GET requests for updates."""
        if self.path == "/fake-update.txt":
            # Serve the malicious update
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(MALICIOUS_UPDATE.encode('utf-8'))
            print(f"[EXPLOIT] Served MALICIOUS update to {self.client_address[0]}")
        
        elif self.path == "/fake-update.txt.sha256":
            # For the secure version, we need to serve a checksum
            # But we'll serve the WRONG checksum (or none at all)
            self.send_response(404)
            self.end_headers()
            print(f"[EXPLOIT] Refused to provide valid checksum (forcing verification failure)")
        
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        """Suppress default logging to keep output clean."""
        pass


def start_malicious_server(port=8000):
    """Start the malicious update server in a background thread."""
    handler = MaliciousUpdateServer
    httpd = socketserver.TCPServer(("", port), handler)
    
    server_thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    server_thread.start()
    
    print(f"\n[*] Malicious update server started on http://localhost:{port}")
    return httpd


def demonstrate_insecure_vulnerability():
    """
    Demonstrates how the insecure application is vulnerable.
    """
    print("\n" + "=" * 70)
    print("DEMONSTRATION: Unvalidated Update Vulnerability (Insecure Version)")
    print("=" * 70)
    
    print("\n[1] Attack Vector:")
    print("    - Application uses HTTP (not HTTPS)")
    print("    - No integrity verification (no checksum/signature check)")
    print("    - Blindly trusts downloaded content")
    
    print("\n[2] Attack Scenario:")
    print("    - Attacker performs MITM attack on HTTP traffic")
    print("    - Intercepts update request to http://example.com/fake-update.txt")
    print("    - Replaces legitimate update with malicious payload")
    print("    - Application downloads and applies malicious update")
    
    print("\n[3] Vulnerable Code (insecure-application.py):")
    print("""
    def download_update() -> str:
        resp = requests.get(UPDATE_URL)  # HTTP, no verification!
        if resp.status_code == 200:
            payload = resp.text
            with open(LOCAL_UPDATE_FILE, "w") as f:
                f.write(payload)  # No integrity check!
            return LOCAL_UPDATE_FILE
    
    def apply_update(file_path: str) -> None:
        with open(file_path, "r") as f:
            content = f.read()
        # Applies update WITHOUT any validation!
    """)
    
    print("\n[4] Impact:")
    print("    - CRITICAL: Remote Code Execution (RCE)")
    print("    - Complete system compromise")
    print("    - Data theft and exfiltration")
    print("    - Backdoor installation")
    print("    - Lateral movement in network")


def demonstrate_secure_protection():
    """
    Demonstrates how the secure application protects against this attack.
    """
    print("\n" + "=" * 70)
    print("PROTECTION: Integrity Verification (Secure Version)")
    print("=" * 70)
    
    print("\n[1] Security Controls:")
    print("    - HTTPS with certificate verification")
    print("    - SHA-256 checksum verification")
    print("    - Rejects updates with invalid checksums")
    print("    - Timeout mechanisms")
    
    print("\n[2] Secure Code (fixed-application.py):")
    print("""
    # Download with HTTPS and cert verification
    resp = requests.get(UPDATE_URL, verify=True, timeout=30)
    payload = resp.text
    
    # Download checksum file
    checksum_resp = requests.get(UPDATE_CHECKSUM_URL, verify=True, timeout=30)
    expected_checksum = checksum_resp.text.strip().split()[0]
    
    # Calculate actual checksum
    actual_checksum = hashlib.sha256(payload.encode('utf-8')).hexdigest()
    
    # Verify integrity
    if actual_checksum != expected_checksum:
        logger.error("Update checksum verification failed!")
        return ""  # REJECT the update!
    """)
    
    print("\n[3] Attack Mitigation:")
    print("    ✓ HTTPS prevents MITM attacks")
    print("    ✓ Checksum verification detects tampering")
    print("    ✓ Malicious updates are rejected")
    print("    ✓ System remains secure")


def create_payload_files():
    """Create example payload files for testing."""
    print("\n[*] Creating example payload files...")
    
    # Create malicious payload
    with open("malicious_update.txt", "w") as f:
        f.write(MALICIOUS_UPDATE)
    print("    Created: malicious_update.txt")
    
    # Create legitimate payload
    with open("legitimate_update.txt", "w") as f:
        f.write(LEGITIMATE_UPDATE)
    print("    Created: legitimate_update.txt")
    
    # Create checksum for legitimate update
    legit_checksum = hashlib.sha256(LEGITIMATE_UPDATE.encode('utf-8')).hexdigest()
    with open("legitimate_update.txt.sha256", "w") as f:
        f.write(f"{legit_checksum}  legitimate_update.txt\n")
    print("    Created: legitimate_update.txt.sha256")
    
    # Create checksum for malicious update (for comparison)
    mal_checksum = hashlib.sha256(MALICIOUS_UPDATE.encode('utf-8')).hexdigest()
    with open("malicious_update.txt.sha256", "w") as f:
        f.write(f"{mal_checksum}  malicious_update.txt\n")
    print("    Created: malicious_update.txt.sha256")
    
    print(f"\n    Legitimate checksum: {legit_checksum}")
    print(f"    Malicious checksum:  {mal_checksum}")
    print(f"    Checksums differ: {legit_checksum != mal_checksum}")


def demonstrate_checksum_verification():
    """Demonstrate checksum verification process."""
    print("\n" + "=" * 70)
    print("DEMONSTRATION: Checksum Verification Process")
    print("=" * 70)
    
    print("\n[*] Testing with legitimate update:")
    legit_content = LEGITIMATE_UPDATE.encode('utf-8')
    legit_checksum = hashlib.sha256(legit_content).hexdigest()
    print(f"    Content length: {len(legit_content)} bytes")
    print(f"    SHA-256: {legit_checksum}")
    print(f"    ✓ Verification: PASS (checksums match)")
    
    print("\n[*] Testing with malicious update:")
    mal_content = MALICIOUS_UPDATE.encode('utf-8')
    mal_checksum = hashlib.sha256(mal_content).hexdigest()
    print(f"    Content length: {len(mal_content)} bytes")
    print(f"    SHA-256: {mal_checksum}")
    
    print(f"\n[*] Attacker trying to pass malicious update as legitimate:")
    print(f"    Expected checksum: {legit_checksum}")
    print(f"    Actual checksum:   {mal_checksum}")
    print(f"    Match: {legit_checksum == mal_checksum}")
    print(f"    ✗ Verification: FAIL (checksums don't match)")
    print(f"    → Update REJECTED by secure application")


def main():
    """Main exploit demonstration."""
    print("""
╔══════════════════════════════════════════════════════════════════════╗
║                                                                      ║
║  Unvalidated Update Vulnerability - Exploit Demonstration           ║
║  CWE-345: Insufficient Verification of Data Authenticity            ║
║                                                                      ║
║  Educational Purpose Only - Do Not Use for Unauthorized Testing     ║
║                                                                      ║
╚══════════════════════════════════════════════════════════════════════╝
    """)
    
    # Demonstrate the vulnerability
    demonstrate_insecure_vulnerability()
    
    # Demonstrate the protection
    demonstrate_secure_protection()
    
    # Create payload files
    create_payload_files()
    
    # Demonstrate checksum verification
    demonstrate_checksum_verification()
    
    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)
    print("\n[VULNERABILITY] CWE-345: Insufficient Verification of Data Authenticity")
    print("├─ Severity: CRITICAL")
    print("├─ CVSS Score: 9.8 (Critical)")
    print("└─ Impact: Remote Code Execution, Complete System Compromise")
    
    print("\n[INSECURE VERSION] insecure-application.py")
    print("├─ ✗ Uses HTTP (plaintext, MITM vulnerable)")
    print("├─ ✗ No integrity verification")
    print("├─ ✗ No signature validation")
    print("└─ ✗ Blindly trusts downloaded content")
    
    print("\n[SECURE VERSION] fixed-application.py")
    print("├─ ✓ Uses HTTPS with certificate verification")
    print("├─ ✓ SHA-256 checksum verification")
    print("├─ ✓ Rejects updates with invalid checksums")
    print("└─ ✓ Timeout and error handling")
    
    print("\n[RECOMMENDATIONS]")
    print("├─ Always use HTTPS for update downloads")
    print("├─ Implement cryptographic signature verification (e.g., GPG)")
    print("├─ Use checksums (SHA-256 or better) for integrity")
    print("├─ Pin TLS certificates or use certificate pinning")
    print("├─ Implement version checking and rollback mechanisms")
    print("└─ Log all update activities for audit trails")
    
    print("\n[FILES CREATED]")
    print("├─ malicious_update.txt - Example malicious payload")
    print("├─ malicious_update.txt.sha256 - Checksum for malicious payload")
    print("├─ legitimate_update.txt - Example legitimate update")
    print("└─ legitimate_update.txt.sha256 - Checksum for legitimate update")
    
    print("\n" + "=" * 70)
    print("Demonstration complete!")
    print("=" * 70 + "\n")


if __name__ == "__main__":
    main()
